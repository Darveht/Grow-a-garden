<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>üåü Garden Dreams - Aventura M√°gica de Plantas</title>
<style>
  :root{
    --glass: rgba(59, 130, 246, 0.15);
    --accent: #1877f2;
    --accent2: #42a5f5;
    --primary: #1565c0;
    --secondary: #64b5f6;
    --blue-primary: #1877f2;
    --blue-secondary: #42a5f5;
    --blue-light: #bbdefb;
    --blue-dark: #0d47a1;
    --success: #4caf50;
    --warning: #ff9800;
  }
  
  html,body{
    height:100%;
    margin:0;
    font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow:hidden;
    background: linear-gradient(135deg, #1565c0 0%, #42a5f5 50%, #64b5f6 100%);
  }
  
  canvas{
    display:block; 
    width:100%; 
    height:100%; 
    touch-action:none; 
    -webkit-user-select:none; 
    user-select:none;
  }
  
  /* ===== INTRO ANIMADO CON VISTA 3D DE DRONE ===== */
  .preIntro{
    position:fixed;
    top:0;
    left:0;
    width:100vw;
    height:100vh;
    background: linear-gradient(45deg, #0d47a1 0%, #1565c0 30%, #1877f2 70%, #42a5f5 100%);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:2000;
    color:white;
    overflow:hidden;
  }
  
  .droneView{
    position:relative;
    width:100%;
    height:100%;
    overflow:hidden;
  }
  
  .skipButton{
    position:absolute;
    bottom:40px;
    right:40px;
    padding:18px 30px;
    background:rgba(255,255,255,0.1);
    backdrop-filter:blur(15px);
    border:2px solid rgba(255,255,255,0.2);
    border-radius:30px;
    color:white;
    font-size:1.1rem;
    font-weight:bold;
    cursor:pointer;
    transition:all 0.3s ease;
    z-index:20;
    text-shadow:0 2px 4px rgba(0,0,0,0.3);
  }
  
  .skipButton:hover{
    background:rgba(255,255,255,0.2);
    transform:scale(1.05);
    box-shadow:0 8px 25px rgba(0,0,0,0.3);
  }
  
  /* ===== PANTALLA DE INICIO ESTILO ROBLOX ===== */
  .startScreen{
    position:fixed;
    top:0;
    left:0;
    width:100vw;
    height:100vh;
    background: 
      radial-gradient(circle at 20% 80%, rgba(24,119,242,0.4) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(66,165,245,0.4) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(13,71,161,0.3) 0%, transparent 50%),
      linear-gradient(135deg, #0d47a1 0%, #1565c0 25%, #1877f2 50%, #42a5f5 75%, #64b5f6 100%);
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:1000;
    color:white;
  }
  
  .gameTitle{
    font-size:clamp(2.5rem, 10vw, 5rem);
    font-weight:900;
    text-align:center;
    margin-bottom:1rem;
    background:linear-gradient(45deg, #ffffff, #bbdefb, #64b5f6);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
    text-shadow:0 0 40px rgba(255,255,255,0.5);
    animation:titleGlow 2s ease-in-out infinite alternate;
  }
  
  @keyframes titleGlow{
    0%{filter:drop-shadow(0 0 20px rgba(255,255,255,0.4))}
    100%{filter:drop-shadow(0 0 40px rgba(187,222,251,0.8))}
  }
  
  .gameSubtitle{
    font-size:1.6rem;
    opacity:0.9;
    margin-bottom:3rem;
    text-align:center;
    color:#bbdefb;
    text-shadow:2px 2px 8px rgba(0,0,0,0.3);
    font-weight:600;
  }
  
  .mainMenu{
    display:flex;
    flex-direction:column;
    gap:2rem;
    min-width:400px;
  }
  
  .menuBtn{
    padding:20px 40px;
    background:rgba(255,255,255,0.1);
    backdrop-filter:blur(20px);
    border:3px solid rgba(255,255,255,0.2);
    border-radius:15px;
    color:white;
    font-size:1.3rem;
    font-weight:700;
    cursor:pointer;
    transition:all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    text-align:center;
    text-shadow:2px 2px 4px rgba(0,0,0,0.3);
    box-shadow:0 10px 30px rgba(0,0,0,0.2);
  }
  
  .menuBtn:hover{
    background:rgba(255,255,255,0.2);
    border-color:rgba(255,255,255,0.4);
    transform:translateY(-8px) scale(1.05);
    box-shadow:0 20px 40px rgba(0,0,0,0.3);
  }
  
  .menuBtn.primary{
    background:linear-gradient(135deg, #1877f2, #42a5f5);
    border-color:#1565c0;
    box-shadow:0 10px 30px rgba(24,119,242,0.4);
  }
  
  .menuBtn.primary:hover{
    background:linear-gradient(135deg, #1565c0, #1877f2);
    box-shadow:0 20px 40px rgba(24,119,242,0.6);
  }
  
  .menuBtn.secondary{
    background:linear-gradient(135deg, #42a5f5, #64b5f6);
    border-color:#1976d2;
    box-shadow:0 10px 30px rgba(66,165,245,0.4);
  }
  
  .menuBtn.secondary:hover{
    background:linear-gradient(135deg, #1976d2, #42a5f5);
    box-shadow:0 20px 40px rgba(66,165,245,0.6);
  }
  
  /* ===== PANEL DE CONFIGURACIONES ===== */
  .settingsPanel{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    width:min(550px, 90vw);
    max-height:85vh;
    background:rgba(13,71,161,0.95);
    backdrop-filter:blur(25px);
    border:3px solid rgba(66,165,245,0.4);
    border-radius:20px;
    padding:2.5rem;
    color:white;
    display:none;
    z-index:1100;
    overflow-y:auto;
    box-shadow:0 25px 80px rgba(0,0,0,0.4);
  }
  
  .settingsHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:2rem;
    border-bottom:2px solid rgba(66,165,245,0.3);
    padding-bottom:1rem;
  }
  
  .settingsHeader h3{
    margin:0;
    font-size:2rem;
    color:white;
    text-shadow:2px 2px 4px rgba(0,0,0,0.3);
  }
  
  .closeBtn{
    background:rgba(255,255,255,0.1);
    border:2px solid rgba(255,255,255,0.3);
    color:white;
    font-size:1.5rem;
    cursor:pointer;
    padding:10px;
    border-radius:50%;
    width:45px;
    height:45px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:bold;
    transition:all 0.3s ease;
  }
  
  .closeBtn:hover{
    background:rgba(255,255,255,0.2);
    transform:scale(1.1);
  }
  
  .settingGroup{
    margin-bottom:2rem;
  }
  
  .settingLabel{
    display:block;
    margin-bottom:0.8rem;
    font-weight:600;
    color:#bbdefb;
    text-shadow:1px 1px 2px rgba(0,0,0,0.3);
    font-size:1.1rem;
  }
  
  .settingControl{
    width:100%;
    padding:15px;
    background:rgba(255,255,255,0.1);
    border:2px solid rgba(66,165,245,0.3);
    border-radius:10px;
    color:white;
    font-size:1rem;
    font-weight:500;
    backdrop-filter:blur(10px);
  }
  
  .settingControl:focus{
    outline:none;
    border-color:#42a5f5;
    box-shadow:0 0 20px rgba(66,165,245,0.4);
    background:rgba(255,255,255,0.15);
  }
  
  .slider{
    -webkit-appearance:none;
    appearance:none;
    height:10px;
    background:rgba(66,165,245,0.3);
    border-radius:5px;
    outline:none;
  }
  
  .slider::-webkit-slider-thumb{
    -webkit-appearance:none;
    appearance:none;
    width:26px;
    height:26px;
    background:linear-gradient(135deg, #1877f2, #42a5f5);
    border-radius:50%;
    cursor:pointer;
    box-shadow:0 4px 15px rgba(24,119,242,0.5);
  }
  
  .checkbox{
    width:auto;
    margin-right:12px;
    transform:scale(1.3);
  }
  
  /* ===== PANEL ONLINE ===== */
  .onlinePanel{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    width:min(650px, 90vw);
    max-height:85vh;
    background:rgba(13,71,161,0.95);
    backdrop-filter:blur(25px);
    border:3px solid rgba(66,165,245,0.4);
    border-radius:20px;
    padding:2.5rem;
    color:white;
    display:none;
    z-index:1100;
    overflow-y:auto;
    box-shadow:0 25px 80px rgba(0,0,0,0.4);
  }
  
  .onlineOptions{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(300px, 1fr));
    gap:2rem;
    margin-top:1.5rem;
  }
  
  .onlineCard{
    background:rgba(255,255,255,0.1);
    border:3px solid rgba(66,165,245,0.3);
    border-radius:15px;
    padding:2.5rem;
    text-align:center;
    cursor:pointer;
    transition:all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    backdrop-filter:blur(15px);
  }
  
  .onlineCard:hover{
    border-color:#42a5f5;
    transform:translateY(-10px) scale(1.03);
    box-shadow:0 25px 50px rgba(66,165,245,0.3);
    background:rgba(255,255,255,0.15);
  }
  
  .onlineCard h4{
    margin:0 0 1.5rem 0;
    color:white;
    font-size:1.5rem;
    text-shadow:2px 2px 4px rgba(0,0,0,0.3);
  }
  
  .onlineCard p{
    color:#bbdefb;
    font-size:1.1rem;
    line-height:1.6;
    font-weight:500;
  }
  
  .roomInput{
    display:flex;
    gap:15px;
    margin-top:1.5rem;
  }
  
  .roomInput input{
    flex:1;
    padding:15px;
    background:rgba(255,255,255,0.1);
    border:2px solid rgba(66,165,245,0.3);
    border-radius:10px;
    color:white;
    font-weight:500;
  }
  
  /* ===== ANIMACIONES ===== */
  @keyframes fadeIn{
    from{opacity:0;transform:translateY(40px) scale(0.9)}
    to{opacity:1;transform:translateY(0) scale(1)}
  }
  
  @keyframes slideIn{
    from{transform:translate(-50%, -80%);opacity:0;scale:0.8}
    to{transform:translate(-50%, -50%);opacity:1;scale:1}
  }
  
  .fadeIn{animation:fadeIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275)}
  .slideIn{animation:slideIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)}
  
  /* ===== ESTILOS DEL JUEGO ===== */
  .gameScreen{
    display:none;
    background: radial-gradient(circle at center, rgba(66,165,245,0.1) 0%, transparent 70%);
  }
  .gameScreen.active{display:block}
  
  .hud{
    position:fixed;
    left:20px;
    right:20px;
    top:20px;
    display:flex;
    gap:15px;
    z-index:120;
    pointer-events:none;
  }
  
  .chip{
    pointer-events:auto;
    background:rgba(13,71,161,0.9);
    backdrop-filter:blur(20px);
    color:white;
    padding:15px 20px;
    border-radius:25px;
    border:2px solid rgba(66,165,245,0.4);
    display:flex;
    align-items:center;
    gap:12px;
    font-weight:700;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
    box-shadow:0 8px 25px rgba(0,0,0,0.2);
  }
  
  .val{font-weight:900; color:#bbdefb}
  
  .dock{
    position:fixed;
    left:0;
    right:0;
    bottom:20px;
    display:flex;
    justify-content:center;
    z-index:130;
    pointer-events:none;
  }
  
  .dockInner{
    pointer-events:auto;
    background:rgba(13,71,161,0.9);
    backdrop-filter:blur(20px);
    padding:15px;
    border-radius:30px;
    display:flex;
    gap:15px;
    border:2px solid rgba(66,165,245,0.4);
    box-shadow:0 15px 40px rgba(0,0,0,0.3);
  }
  
  .btn{
    min-width:80px;
    padding:15px 25px;
    border-radius:20px;
    background:linear-gradient(135deg, rgba(24,119,242,0.8), rgba(66,165,245,0.6));
    color:white;
    font-weight:700;
    border:2px solid rgba(66,165,245,0.4);
    cursor:pointer;
    transition:all 0.3s ease;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
  }
  
  .btn:hover{
    transform:translateY(-3px) scale(1.05);
    box-shadow:0 10px 30px rgba(24,119,242,0.4);
    background:linear-gradient(135deg, rgba(21,101,192,0.9), rgba(24,119,242,0.7));
  }
  
  .joystick{
    position:fixed;
    left:20px;
    bottom:140px;
    z-index:160;
    width:160px;
    height:160px;
    pointer-events:auto;
  }
  
  .joyBase{
    width:100%;
    height:100%;
    border-radius:50%;
    background:radial-gradient(circle at 30% 30%, rgba(13,71,161,0.6), rgba(24,119,242,0.3));
    border:3px solid rgba(66,165,245,0.4);
    box-shadow:inset 0 8px 25px rgba(0,0,0,0.2);
  }
  
  .joyKnob{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:80px;
    height:80px;
    border-radius:50%;
    background:linear-gradient(135deg, rgba(24,119,242,0.9), rgba(66,165,245,0.7));
    border:3px solid rgba(66,165,245,0.6);
    box-shadow:0 8px 25px rgba(0,0,0,0.3);
  }
  
  .lookPad{
    position:fixed;
    right:0;
    top:0;
    bottom:0;
    width:50vw;
    z-index:100;
    pointer-events:auto;
  }
  
  .inventoryPanel{
    position:fixed;
    right:20px;
    top:100px;
    width:240px;
    background:rgba(13,71,161,0.9);
    color:white;
    padding:20px;
    border-radius:25px;
    z-index:140;
    backdrop-filter:blur(20px);
    border:2px solid rgba(66,165,245,0.4);
    box-shadow:0 15px 40px rgba(0,0,0,0.2);
  }
  
  .inventoryTitle{
    font-weight:800;
    margin-bottom:15px;
    text-align:center;
    color:#bbdefb;
    font-size:1.2rem;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
  }
  
  .inventoryGrid{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:8px;
  }
  
  .inventorySlot{
    aspect-ratio:1;
    background:rgba(255,255,255,0.1);
    border-radius:15px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    font-size:20px;
    border:2px solid rgba(66,165,245,0.3);
    transition:all 0.3s ease;
  }
  
  .inventorySlot.has-item{
    background:rgba(76,175,80,0.3);
    border-color:#4caf50;
    box-shadow:0 5px 15px rgba(76,175,80,0.3);
  }
  
  .slotCount{
    font-size:12px;
    font-weight:800;
    color:#bbdefb;
  }
  
  .storePanel{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:min(700px,95vw);
    max-height:85vh;
    background:rgba(13,71,161,0.95);
    color:white;
    padding:25px;
    border-radius:25px;
    display:none;
    z-index:900;
    overflow-y:auto;
    backdrop-filter:blur(25px);
    border:3px solid rgba(66,165,245,0.4);
    box-shadow:0 25px 80px rgba(0,0,0,0.4);
  }
  
  .storeHeader{
    display:flex;
    align-items:center;
    justify-content:space-between;
    margin-bottom:25px;
    border-bottom:2px solid rgba(66,165,245,0.3);
    padding-bottom:20px;
  }
  
  .storeHeader h3{
    color:white;
    font-size:1.8rem;
    text-shadow:2px 2px 4px rgba(0,0,0,0.3);
  }
  
  .seedGrid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    gap:20px;
    margin-bottom:25px;
  }
  
  .seedDisplay{
    background:rgba(255,255,255,0.1);
    border-radius:20px;
    padding:20px;
    text-align:center;
    border:3px solid rgba(66,165,245,0.3);
    transition:all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor:pointer;
    backdrop-filter:blur(15px);
  }
  
  .seedDisplay:hover{
    border-color:#42a5f5;
    transform:translateY(-8px) scale(1.03);
    box-shadow:0 20px 40px rgba(66,165,245,0.4);
    background:rgba(255,255,255,0.15);
  }
  
  .seedIcon{
    width:80px;
    height:80px;
    margin:0 auto 15px;
    background:linear-gradient(45deg, #4caf50, #8bc34a);
    border-radius:20px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:36px;
    box-shadow:0 8px 25px rgba(76,175,80,0.4);
  }
  
  .seedName{
    font-weight:800;
    margin-bottom:8px;
    color:white;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
    font-size:1.1rem;
  }
  
  .seedPrice{
    color:#bbdefb;
    font-weight:700;
    margin-bottom:12px;
    font-size:1.2rem;
  }
  
  .seedDesc{
    font-size:1rem;
    color:#bbdefb;
    margin-bottom:15px;
    line-height:1.5;
  }
  
  .cartPanel{
    position:fixed;
    right:20px;
    top:50%;
    transform:translateY(-50%);
    width:350px;
    background:rgba(13,71,161,0.95);
    color:white;
    padding:25px;
    border-radius:25px;
    display:none;
    z-index:910;
    backdrop-filter:blur(25px);
    border:3px solid rgba(66,165,245,0.4);
    box-shadow:0 20px 60px rgba(0,0,0,0.3);
  }
  
  .cartItem{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px;
    background:rgba(255,255,255,0.1);
    border-radius:15px;
    margin-bottom:12px;
    border:2px solid rgba(66,165,245,0.2);
  }
  
  .cartTotal{
    border-top:2px solid rgba(66,165,245,0.4);
    padding-top:20px;
    margin-top:20px;
    font-weight:800;
    font-size:1.3rem;
    color:#bbdefb;
    text-align:center;
  }
  
  .deliveryBox{
    position:fixed;
    left:50%;
    bottom:30px;
    transform:translateX(-50%);
    background:rgba(13,71,161,0.95);
    color:white;
    padding:25px;
    border-radius:25px;
    display:none;
    z-index:920;
    text-align:center;
    cursor:pointer;
    border:3px solid #42a5f5;
    backdrop-filter:blur(20px);
    transition:all 0.3s ease;
    box-shadow:0 15px 40px rgba(0,0,0,0.3);
  }
  
  .deliveryBox:hover{
    background:rgba(21,101,192,0.95);
    transform:translateX(-50%) scale(1.05);
    box-shadow:0 20px 50px rgba(0,0,0,0.4);
  }
  
  .ticketInfo{
    background:rgba(255,255,255,0.1);
    padding:12px;
    border-radius:15px;
    margin:12px 0;
    font-size:1rem;
    border:2px solid rgba(66,165,245,0.3);
  }
  
  .toast{
    position:fixed;
    left:50%;
    top:120px;
    transform:translateX(-50%);
    background:rgba(13,71,161,0.95);
    color:white;
    padding:15px 25px;
    border-radius:20px;
    display:none;
    z-index:920;
    font-weight:600;
    backdrop-filter:blur(20px);
    border:2px solid rgba(66,165,245,0.4);
    box-shadow:0 10px 35px rgba(0,0,0,0.3);
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
  }
  
  .npcDialog{
    position:fixed;
    left:50%;
    bottom:200px;
    transform:translateX(-50%);
    background:rgba(255,255,255,0.98);
    color:#0d47a1;
    padding:20px 25px;
    border-radius:25px;
    display:none;
    z-index:930;
    max-width:380px;
    text-align:center;
    border:3px solid rgba(66,165,245,0.4);
    box-shadow:0 15px 40px rgba(0,0,0,0.3);
  }
  
  .npcName{
    font-weight:800;
    color:#1565c0;
    margin-bottom:10px;
    font-size:1.2rem;
  }
  
  .touchIndicator{
    position:absolute;
    pointer-events:none;
    width:40px;
    height:40px;
    border:4px solid #42a5f5;
    border-radius:50%;
    animation:touchPulse 0.8s ease-out;
    box-shadow:0 0 20px rgba(66,165,245,0.6);
  }
  
  @keyframes touchPulse{
    from{transform:scale(0);opacity:1}
    to{transform:scale(1.3);opacity:0}
  }
  
  .backBtn{
    position:absolute;
    top:30px;
    left:30px;
    background:rgba(13,71,161,0.9);
    backdrop-filter:blur(20px);
    border:3px solid rgba(66,165,245,0.4);
    border-radius:20px;
    color:white;
    padding:15px 25px;
    cursor:pointer;
    font-weight:600;
    transition:all 0.3s ease;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
  }
  
  .backBtn:hover{
    background:rgba(21,101,192,0.9);
    border-color:#42a5f5;
    transform:scale(1.05);
  }

  /* ===== CLIMA Y TIEMPO ===== */
  .weatherHud{
    position:fixed;
    top:20px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(13,71,161,0.9);
    backdrop-filter:blur(20px);
    color:white;
    padding:15px 25px;
    border-radius:25px;
    border:2px solid rgba(66,165,245,0.4);
    z-index:125;
    font-weight:700;
    text-shadow:1px 1px 3px rgba(0,0,0,0.3);
    box-shadow:0 8px 25px rgba(0,0,0,0.2);
    text-align:center;
  }

  .rainEffect{
    position:fixed;
    top:0;
    left:0;
    width:100vw;
    height:100vh;
    pointer-events:none;
    z-index:50;
  }
</style>
</head>
<body>
  <!-- ===== INTRO ANIMADO CON VISTA 3D DE DRONE ===== -->
  <div class="preIntro" id="preIntro">
    <div class="droneView" id="droneView"></div>
    <button class="skipButton" id="skipIntro">‚è≠Ô∏è Omitir Vista</button>
  </div>

  <!-- ===== PANTALLA DE INICIO ===== -->
  <div class="startScreen" id="startScreen">
    <div class="fadeIn">
      <h1 class="gameTitle">üåü Garden Dreams</h1>
      <p class="gameSubtitle">‚ú® Aventura M√°gica de Plantas ‚ú®</p>
      
      <div class="mainMenu">
        <button class="menuBtn primary" id="btnPlay">üéÆ ¬°Jugar Solo!</button>
        <button class="menuBtn secondary" id="btnOnline">üåê Modo Online</button>
        <button class="menuBtn" id="btnSettings">‚öôÔ∏è Configuraciones</button>
        <button class="menuBtn" id="btnCredits">üíñ Cr√©ditos</button>
      </div>
    </div>
  </div>

  <!-- ===== PANEL DE CONFIGURACIONES ===== -->
  <div class="settingsPanel slideIn" id="settingsPanel">
    <div class="settingsHeader">
      <h3>‚öôÔ∏è Configuraciones M√°gicas</h3>
      <button class="closeBtn" id="closeSettings">‚úï</button>
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üßö‚Äç‚ôÄÔ∏è Nombre del Jardinero</label>
      <input type="text" class="settingControl" id="playerName" placeholder="Tu nombre m√°gico" value="Jardinero M√°gico">
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üè∞ Nombre del Jard√≠n</label>
      <input type="text" class="settingControl" id="farmNameInput" placeholder="Nombre de tu jard√≠n" value="Jard√≠n de Ensue√±os">
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üîä Sonidos M√°gicos: <span id="sfxValue">80</span>%</label>
      <input type="range" class="settingControl slider" id="sfxVolume" min="0" max="100" value="80">
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üéµ M√∫sica Encantada: <span id="musicValue">60</span>%</label>
      <input type="range" class="settingControl slider" id="musicVolume" min="0" max="100" value="60">
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üí∞ Monedas M√°gicas Iniciales</label>
      <select class="settingControl" id="startingMoney">
        <option value="50">Principiante - 50 monedas ‚ú®</option>
        <option value="100">Intermedio - 100 monedas üåü</option>
        <option value="200">Avanzado - 200 monedas üé≠</option>
        <option value="500">Experto - 500 monedas üëë</option>
      </select>
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">
        <input type="checkbox" class="checkbox" id="autoSave" checked>
        üíæ Guardado Autom√°tico M√°gico
      </label>
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">
        <input type="checkbox" class="checkbox" id="showTutorial" checked>
        üìñ Tutorial para Principiantes
      </label>
    </div>
    
    <div class="settingGroup">
      <label class="settingLabel">üé® Tema Visual Encantado</label>
      <select class="settingControl" id="visualTheme">
        <option value="default">Reino Azul Cl√°sico</option>
        <option value="dark">Oc√©ano Profundo</option>
        <option value="colorful">Aurora Boreal</option>
        <option value="minimal">Cielo Minimalista</option>
      </select>
    </div>
    
    <button class="menuBtn primary" id="saveSettings" style="width:100%;margin-top:1.5rem">üíæ Guardar Configuraci√≥n</button>
  </div>

  <!-- ===== PANEL ONLINE ===== -->
  <div class="onlinePanel slideIn" id="onlinePanel">
    <div class="settingsHeader">
      <h3>üåê Aventura Online</h3>
      <button class="closeBtn" id="closeOnline">‚úï</button>
    </div>
    
    <div class="onlineOptions">
      <div class="onlineCard" id="createRoom">
        <h4>üèóÔ∏è Crear Jard√≠n M√°gico</h4>
        <p>Crea tu propio jard√≠n encantado e invita a tus amigos para cultivar plantas m√°gicas juntos. ¬°T√∫ ser√°s el guardi√°n principal!</p>
      </div>
      
      <div class="onlineCard" id="joinRoom">
        <h4>üö™ Unirse a Jard√≠n</h4>
        <p>√önete a un jard√≠n m√°gico existente con un c√≥digo especial. ¬°Colabora con otros jardineros en aventuras incre√≠bles!</p>
        <div class="roomInput">
          <input type="text" placeholder="C√≥digo m√°gico" id="roomCode" maxlength="6">
          <button class="menuBtn" id="joinRoomBtn">¬°Entrar!</button>
        </div>
      </div>
      
      <div class="onlineCard" id="quickMatch">
        <h4>‚ö° Jard√≠n R√°pido</h4>
        <p>¬°Encuentra autom√°ticamente un jard√≠n disponible y comienza tu aventura m√°gica inmediatamente!</p>
      </div>
      
      <div class="onlineCard" id="leaderboard">
        <h4>üèÜ Jardineros Legendarios</h4>
        <p>Mira los jardines m√°s hermosos del mundo m√°gico, compite por ser el mejor y gana premios especiales.</p>
      </div>
    </div>
    
    <button class="backBtn" id="backFromOnline">‚Üê Regresar</button>
  </div>

  <!-- ===== JUEGO ===== -->
  <div class="gameScreen" id="gameScreen">
    <div class="hud">
      <div class="chip">üí∞ <span class="val" id="money">50</span></div>
      <div style="margin-left:auto" class="chip" id="farmTag">üè∞ <span id="farmName">Jard√≠n de Ensue√±os</span></div>
    </div>

    <div class="weatherHud" id="weatherHud">
      <div id="timeDisplay">‚òÄÔ∏è D√≠a - 12:00</div>
      <div id="weatherDisplay">‚òÄÔ∏è Soleado</div>
    </div>

    <div class="inventoryPanel">
      <div class="inventoryTitle">üéí Bolsa M√°gica</div>
      <div class="inventoryGrid" id="inventoryGrid"></div>
    </div>

    <div class="dock">
      <div class="dockInner">
        <button class="btn" id="btnJump">Saltar ‚ú®</button>
        <button class="btn" id="btnInteract">Interactuar üåü</button>
        <button class="btn" id="btnMenu">Men√∫ üé≠</button>
      </div>
    </div>

    <div class="joystick" id="joystick">
      <div class="joyBase"></div>
      <div class="joyKnob" id="knob"></div>
    </div>
    <div class="lookPad" id="lookPad"></div>

    <div class="rainEffect" id="rainEffect"></div>

    <div class="storePanel" id="storePanel">
      <div class="storeHeader">
        <h3>üè™ Tienda de Semillas M√°gicas</h3>
        <button class="btn" id="closeStore">Cerrar</button>
      </div>
      <div class="seedGrid" id="seedGrid"></div>
      <div style="display:flex;gap:20px;justify-content:center">
        <button class="btn" id="viewCart">üõí Carrito (<span id="cartCount">0</span>)</button>
        <button class="btn" id="checkout">üí´ Comprar</button>
      </div>
    </div>

    <div class="cartPanel" id="cartPanel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
        <h4>üõí Carrito M√°gico</h4>
        <button class="btn" id="closeCart">‚úï</button>
      </div>
      <div id="cartItems"></div>
      <div class="cartTotal">
        Total M√°gico: <span id="cartTotalAmount">0</span> monedas ‚ú®
      </div>
      <button class="btn" id="proceedCheckout" style="width:100%;margin-top:20px">üí´ Finalizar Compra</button>
    </div>

    <div class="deliveryBox" id="deliveryBox">
      <div>üì¶ ¬°Tu Pedido M√°gico Ha Llegado!</div>
      <div class="ticketInfo">
        <div>üßæ Ticket M√°gico #<span id="orderNumber">001</span></div>
        <div>üìã <span id="orderItems">Semillas encantadas</span></div>
      </div>
      <div>üëÜ Toca para abrir la caja m√°gica</div>
    </div>

    <div class="npcDialog" id="npcDialog">
      <div class="npcName">üßô‚Äç‚ôÇÔ∏è Mago de las Semillas</div>
      <div id="npcMessage">¬°Bienvenido a la Tienda de Semillas M√°gicas! ¬øQu√© plantas encantadas deseas cultivar?</div>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>

  <script>
  // ----- CONFIGURACI√ìN Y ESTADO -----
  let gameConfig = {
    playerName: 'Jardinero M√°gico',
    farmName: 'Jard√≠n de Ensue√±os',
    sfxVolume: 80,
    musicVolume: 60,
    startingMoney: 50,
    autoSave: true,
    showTutorial: true,
    visualTheme: 'default'
  };

  let state = { 
    money: 50, 
    farmName: 'Jard√≠n de Ensue√±os', 
    plants: [],
    cart: [],
    inventory: {
      carrot: 3,
      tomato: 2,
      corn: 0,
      lettuce: 1,
      potato: 0,
      pepper: 0
    },
    orderCounter: 1,
    npcState: 'idle',
    gameStarted: false,
    introCompleted: false
  };

  // ----- SISTEMA DE TIEMPO Y CLIMA -----
  let timeSystem = {
    currentTime: 0, // 0-24 horas
    dayDuration: 120000, // 2 minutos = 1 d√≠a completo
    weather: 'sunny', // sunny, rainy, cloudy
    weatherDuration: 0,
    lastWeatherChange: 0,
    isRaining: false
  };

  const seedCatalog = [
    {id: 'carrot', name: 'Zanahoria M√°gica', price: 2, desc: 'Crece r√°pido con brillos dorados', icon: 'ü•ï', color: 0xFF6B35, growTime: 8000},
    {id: 'tomato', name: 'Tomate Encantado', price: 4, desc: 'Jugoso con poderes especiales', icon: 'üçÖ', color: 0xFF4444, growTime: 12000},
    {id: 'corn', name: 'Ma√≠z Celestial', price: 6, desc: 'Dorado como el sol, muy poderoso', icon: 'üåΩ', color: 0xFFD700, growTime: 15000},
    {id: 'lettuce', name: 'Lechuga de Hada', price: 3, desc: 'Fresca con chispas verdes', icon: 'ü•¨', color: 0x4CAF50, growTime: 10000},
    {id: 'potato', name: 'Papa del Tesoro', price: 5, desc: 'Contiene monedas de oro', icon: 'ü•î', color: 0x8D6E63, growTime: 14000},
    {id: 'pepper', name: 'Pimiento de Fuego', price: 7, desc: 'Ardiente con llamas m√°gicas', icon: 'üå∂Ô∏è', color: 0xF44336, growTime: 16000}
  ];

  // ----- ELEMENTOS DOM -----
  const preIntro = document.getElementById('preIntro');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const settingsPanel = document.getElementById('settingsPanel');
  const onlinePanel = document.getElementById('onlinePanel');
  const droneView = document.getElementById('droneView');

  // ----- INTRO ANIMADO CON VISTA 3D DE DRONE -----
  let droneScene, droneCamera, droneRenderer;
  let dronePlots = [], droneCrops, droneStoreBuilding, storeBase;
  let droneAnimationId;

  function createDroneIntro() {
    // Configurar Three.js para la vista de drone
    droneScene = new THREE.Scene();
    droneScene.background = new THREE.Color(0x87CEEB);
    
    droneCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    droneCamera.position.set(0, 25, 30);
    
    droneRenderer = new THREE.WebGLRenderer({antialias: true});
    droneRenderer.setSize(window.innerWidth, window.innerHeight);
    droneRenderer.shadowMap.enabled = true;
    droneRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    droneView.appendChild(droneRenderer.domElement);
    
    // Iluminaci√≥n para la vista de drone
    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x4CAF50, 0.8);
    droneScene.add(hemiLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(20, 30, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    droneScene.add(dirLight);
    
    // Suelo del jard√≠n
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    droneScene.add(ground);
    
    // Crear plots de siembra con mejor color
    const plotSize = 3;
    const gap = 1;
    for(let rz = 0; rz < 4; rz++) {
      for(let cx = 0; cx < 5; cx++) {
        const x = -8 + cx * (plotSize + gap);
        const z = -6 + rz * (plotSize + gap);
        
        // Suelo de la parcela con color tierra m√°s natural
        const plotGeo = new THREE.BoxGeometry(plotSize, 0.2, plotSize);
        const plotMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Marr√≥n tierra
        const plot = new THREE.Mesh(plotGeo, plotMat);
        plot.position.set(x, 0.1, z);
        plot.castShadow = true;
        plot.receiveShadow = true;
        droneScene.add(plot);
        
        // Bordes de la parcela con color azul
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x1877f2 });
        const frameThickness = 0.3;
        const frameHeight = 0.4;
        
        // Crear marcos alrededor de cada parcela
        const frames = [
          { pos: [x, frameHeight/2, z - plotSize/2 - frameThickness/2], size: [plotSize + frameThickness, frameHeight, frameThickness] },
          { pos: [x, frameHeight/2, z + plotSize/2 + frameThickness/2], size: [plotSize + frameThickness, frameHeight, frameThickness] },
          { pos: [x - plotSize/2 - frameThickness/2, frameHeight/2, z], size: [frameThickness, frameHeight, plotSize] },
          { pos: [x + plotSize/2 + frameThickness/2, frameHeight/2, z], size: [frameThickness, frameHeight, plotSize] }
        ];
        
        frames.forEach(frame => {
          const frameGeo = new THREE.BoxGeometry(...frame.size);
          const frameMesh = new THREE.Mesh(frameGeo, frameMat);
          frameMesh.position.set(...frame.pos);
          frameMesh.castShadow = true;
          droneScene.add(frameMesh);
        });
        
        // Agregar algunas plantas aleatorias para que se vea vivo
        if (Math.random() < 0.6) {
          const plantGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8);
          const plantMat = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
          const plant = new THREE.Mesh(plantGeo, plantMat);
          plant.position.set(
            x + (Math.random() - 0.5) * plotSize * 0.6,
            0.75,
            z + (Math.random() - 0.5) * plotSize * 0.6
          );
          plant.castShadow = true;
          droneScene.add(plant);
        }
      }
    }
    
    // Tienda con colores azules
    storeBase = new THREE.Mesh(
      new THREE.BoxGeometry(15, 6, 10),
      new THREE.MeshLambertMaterial({ color: 0x1877f2 })
    );
    storeBase.position.set(0, 3, -25);
    storeBase.castShadow = true;
    droneScene.add(storeBase);
    
    const roof = new THREE.Mesh(
      new THREE.BoxGeometry(16, 0.5, 11),
      new THREE.MeshLambertMaterial({ color: 0x0d47a1 })
    );
    roof.position.set(0, 6.25, -25);
    droneScene.add(roof);
    
    // Letrero de la tienda
    const signGeo = new THREE.BoxGeometry(10, 1.5, 0.3);
    const signMat = new THREE.MeshLambertMaterial({ color: 0x42a5f5 });
    const sign = new THREE.Mesh(signGeo, signMat);
    sign.position.set(0, 4.5, -19.8);
    droneScene.add(sign);
    
    // √Årboles decorativos
    for(let i = 0; i < 8; i++) {
      const treeX = (Math.random() - 0.5) * 80;
      const treeZ = (Math.random() - 0.5) * 80;
      
      // Evitar que los √°rboles est√©n muy cerca de las parcelas o la tienda
      if (Math.abs(treeX) < 20 && Math.abs(treeZ + 10) < 20) continue;
      
      const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 4);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.set(treeX, 2, treeZ);
      trunk.castShadow = true;
      droneScene.add(trunk);
      
      const leavesGeo = new THREE.SphereGeometry(3);
      const leavesMat = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
      const leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.set(treeX, 5, treeZ);
      leaves.castShadow = true;
      droneScene.add(leaves);
    }
    
    // Iniciar animaci√≥n de drone
    startDroneAnimation();
  }

  let spaceship, fireParticles, colorTunnel, magicTree, lightning;
  let epicSequenceStarted = false;
  let victorySequenceStarted = false;

  function startDroneAnimation() {
    const startTime = Date.now();
    let angle = 0;
    
    function animateDrone() {
      if (!state.introCompleted) {
        const elapsed = Date.now() - startTime;
        
        // Despu√©s de 8 segundos, iniciar secuencia √©pica
        if (elapsed > 8000 && !epicSequenceStarted) {
          epicSequenceStarted = true;
          createSpaceshipSequence();
        }
        
        // Durante los primeros 8 segundos: vista 360 normal
        if (elapsed <= 8000) {
          // Movimiento circular de drone elev√°ndose gradualmente
          const radius = 35 - (elapsed * 0.005); // Se acerca gradualmente
          const height = 25 + Math.sin(elapsed * 0.001) * 5; // Movimiento vertical suave
          
          angle += 0.008; // Velocidad de rotaci√≥n
          
          droneCamera.position.x = Math.sin(angle) * radius;
          droneCamera.position.z = Math.cos(angle) * radius;
          droneCamera.position.y = height;
          
          // La c√°mara siempre mira hacia el centro del jard√≠n
          droneCamera.lookAt(0, 0, 0);
        } else {
          // Secuencia √©pica del mu√±eco gigante
          animateEpicSequence(elapsed - 8000);
        }
        
        // Renderizar la escena
        droneRenderer.render(droneScene, droneCamera);
        
        // Continuar animaci√≥n
        droneAnimationId = requestAnimationFrame(animateDrone);
      }
    }
    
    animateDrone();
  }

  function createSpaceshipSequence() {
    // Crear nave espacial M√ÅS DETALLADA
    spaceship = new THREE.Group();
    
    // Cuerpo principal de la nave (plateado con m√°s detalle)
    const bodyGeo = new THREE.CylinderGeometry(2.5, 4.5, 15);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 7;
    spaceship.add(body);
    
    // Secciones del cuerpo para m√°s detalle
    for(let i = 0; i < 4; i++) {
      const sectionGeo = new THREE.CylinderGeometry(2.3, 2.3, 0.5);
      const sectionMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
      const section = new THREE.Mesh(sectionGeo, sectionMat);
      section.position.y = 2 + (i * 3);
      spaceship.add(section);
    }
    
    // Punta de la nave (dorada con m√°s detalle)
    const tipGeo = new THREE.ConeGeometry(2.5, 5);
    const tipMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
    const tip = new THREE.Mesh(tipGeo, tipMat);
    tip.position.y = 17;
    spaceship.add(tip);
    
    // Antena en la punta
    const antennaGeo = new THREE.CylinderGeometry(0.1, 0.1, 2);
    const antennaMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const antenna = new THREE.Mesh(antennaGeo, antennaMat);
    antenna.position.y = 20.5;
    spaceship.add(antenna);
    
    // Alas laterales M√ÅS GRANDES Y DETALLADAS
    const wingGeo = new THREE.BoxGeometry(12, 1.5, 4);
    const wingMat = new THREE.MeshLambertMaterial({ color: 0x1877f2 });
    
    const leftWing = new THREE.Mesh(wingGeo, wingMat);
    leftWing.position.set(-6, 8, 0);
    spaceship.add(leftWing);
    
    const rightWing = new THREE.Mesh(wingGeo, wingMat);
    rightWing.position.set(6, 8, 0);
    spaceship.add(rightWing);
    
    // Motores en las alas
    for(let side = 0; side < 2; side++) {
      const engineGeo = new THREE.CylinderGeometry(0.8, 1.2, 3);
      const engineMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const engine = new THREE.Mesh(engineGeo, engineMat);
      engine.position.set(side === 0 ? -8 : 8, 7, 0);
      spaceship.add(engine);
    }
    
    // Cabina (transparente azul M√ÅS GRANDE)
    const cabinGeo = new THREE.SphereGeometry(2);
    const cabinMat = new THREE.MeshLambertMaterial({ 
      color: 0x42a5f5, 
      transparent: true, 
      opacity: 0.7 
    });
    const cabin = new THREE.Mesh(cabinGeo, cabinMat);
    cabin.position.y = 12;
    spaceship.add(cabin);
    
    // Ventanas de la cabina
    for(let i = 0; i < 6; i++) {
      const windowGeo = new THREE.CircleGeometry(0.3);
      const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0x444444 });
      const window = new THREE.Mesh(windowGeo, windowMat);
      const angle = (i / 6) * Math.PI * 2;
      window.position.set(
        Math.cos(angle) * 1.8,
        12,
        Math.sin(angle) * 1.8
      );
      window.lookAt(0, 12, 0);
      spaceship.add(window);
    }
    
    // Propulsores en la base M√ÅS GRANDES
    for(let i = 0; i < 4; i++) {
      const thrusterGeo = new THREE.CylinderGeometry(0.8, 1.2, 3);
      const thrusterMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const thruster = new THREE.Mesh(thrusterGeo, thrusterMat);
      const angle = (i / 4) * Math.PI * 2;
      thruster.position.set(
        Math.cos(angle) * 3,
        -2,
        Math.sin(angle) * 3
      );
      spaceship.add(thruster);
      
      // Tubos de escape internos
      const pipeGeo = new THREE.CylinderGeometry(0.4, 0.6, 2);
      const pipeMat = new THREE.MeshBasicMaterial({ color: 0xff4400, emissive: 0x442200 });
      const pipe = new THREE.Mesh(pipeGeo, pipeMat);
      pipe.position.set(
        Math.cos(angle) * 3,
        -2.5,
        Math.sin(angle) * 3
      );
      spaceship.add(pipe);
    }
    
    // POSICIONAR MUY LEJOS DEL √ÅREA DEL JUEGO
    spaceship.position.set(-100, -20, -100); // Mucho m√°s lejos del huerto y bajo tierra inicialmente
    droneScene.add(spaceship);
    
    // Crear sistema de part√≠culas de fuego
    createFireSystem();
    
    // Crear t√∫nel de colores (invisible inicialmente)
    createColorTunnel();
    
    // Crear √°rbol m√°gico (invisible inicialmente)
    createMagicTree();
  }
  
  function createFireSystem() {
    fireParticles = new THREE.Group();
    
    // M√ÅS PART√çCULAS DE FUEGO Y M√ÅS REALISTAS
    for(let i = 0; i < 150; i++) {
      const flameGeo = new THREE.SphereGeometry(0.2 + Math.random() * 0.4);
      const hue = 0.15 - Math.random() * 0.15; // M√°s variedad en colores de fuego
      const flameMat = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color().setHSL(hue, 1, 0.5 + Math.random() * 0.3),
        transparent: true,
        opacity: 0.7 + Math.random() * 0.3
      });
      const flame = new THREE.Mesh(flameGeo, flameMat);
      
      // Posicionar llamas aleatoriamente debajo de la nave (MUY LEJOS DEL HUERTO)
      flame.position.set(
        -100 + (Math.random() - 0.5) * 15, // Centrado en la nueva posici√≥n de la nave
        -25 - Math.random() * 8, // M√°s abajo para que no se vea inicialmente
        -100 + (Math.random() - 0.5) * 15
      );
      
      flame.userData = {
        initialY: flame.position.y,
        initialX: flame.position.x,
        initialZ: flame.position.z,
        speed: 1.5 + Math.random() * 3,
        life: Math.random(),
        bobSpeed: 0.5 + Math.random() * 1.5
      };
      
      fireParticles.add(flame);
    }
    
    // Humo adicional
    for(let i = 0; i < 30; i++) {
      const smokeGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5);
      const smokeMat = new THREE.MeshBasicMaterial({ 
        color: 0x555555,
        transparent: true,
        opacity: 0.3 + Math.random() * 0.4
      });
      const smoke = new THREE.Mesh(smokeGeo, smokeMat);
      
      smoke.position.set(
        -100 + (Math.random() - 0.5) * 20,
        -18 + Math.random() * 10, // M√°s abajo inicialmente
        -100 + (Math.random() - 0.5) * 20
      );
      
      smoke.userData = {
        initialY: smoke.position.y,
        speed: 0.5 + Math.random() * 1,
        life: Math.random(),
        isSmoke: true
      };
      
      fireParticles.add(smoke);
    }
    
    fireParticles.visible = false;
    droneScene.add(fireParticles);
  }
  
  function createColorTunnel() {
    colorTunnel = new THREE.Group();
    
    // Crear anillos de colores
    for(let i = 0; i < 30; i++) {
      const ringGeo = new THREE.TorusGeometry(20 + i * 5, 2, 8, 16);
      const hue = (i * 0.1) % 1;
      const ringMat = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color().setHSL(hue, 1, 0.5),
        transparent: true,
        opacity: 0.6
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.z = i * -20;
      ring.userData = { originalZ: ring.position.z };
      colorTunnel.add(ring);
    }
    
    colorTunnel.visible = false;
    droneScene.add(colorTunnel);
  }
  
  function createMagicTree() {
    magicTree = new THREE.Group();
    
    // Tronco del √°rbol M√ÅS DETALLADO
    const trunkGeo = new THREE.CylinderGeometry(1.5, 2.5, 12);
    const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 6;
    magicTree.add(trunk);
    
    // Textura del tronco con anillos
    for(let i = 0; i < 6; i++) {
      const ringGeo = new THREE.CylinderGeometry(1.6, 1.6, 0.3);
      const ringMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 2 + (i * 2);
      magicTree.add(ring);
    }
    
    // Copa del √°rbol M√ÅS GRANDE Y DETALLADA
    const leavesGeo = new THREE.SphereGeometry(8);
    const leavesMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
    leaves.position.y = 14;
    magicTree.add(leaves);
    
    // Copas adicionales para m√°s volumen
    for(let i = 0; i < 4; i++) {
      const extraLeavesGeo = new THREE.SphereGeometry(4 + Math.random() * 2);
      const extraLeavesMat = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
      const extraLeaves = new THREE.Mesh(extraLeavesGeo, extraLeavesMat);
      const angle = (i / 4) * Math.PI * 2;
      extraLeaves.position.set(
        Math.cos(angle) * 5,
        12 + Math.random() * 4,
        Math.sin(angle) * 5
      );
      magicTree.add(extraLeaves);
    }
    
    // Ramas principales M√ÅS GRUESAS
    for(let i = 0; i < 12; i++) {
      const branchGeo = new THREE.CylinderGeometry(0.3, 0.8, 5);
      const branchMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
      const branch = new THREE.Mesh(branchGeo, branchMat);
      const angle = (i / 12) * Math.PI * 2;
      const height = 8 + Math.random() * 6;
      branch.position.set(
        Math.cos(angle) * (3 + Math.random() * 2),
        height,
        Math.sin(angle) * (3 + Math.random() * 2)
      );
      branch.rotation.z = angle + (Math.random() - 0.5) * 0.5;
      branch.rotation.x = (Math.random() - 0.5) * 0.3;
      magicTree.add(branch);
    }
    
    // Ra√≠ces visibles
    for(let i = 0; i < 6; i++) {
      const rootGeo = new THREE.CylinderGeometry(0.8, 0.4, 3);
      const rootMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const root = new THREE.Mesh(rootGeo, rootMat);
      const angle = (i / 6) * Math.PI * 2;
      root.position.set(
        Math.cos(angle) * 2.5,
        -0.5,
        Math.sin(angle) * 2.5
      );
      root.rotation.z = angle;
      root.rotation.x = Math.PI / 6;
      magicTree.add(root);
    }
    
    // POSICIONAR FUERA DEL √ÅREA DEL JUEGO
    magicTree.position.set(30, 0, 30); // Lejos del huerto, en otra √°rea
    magicTree.scale.set(0.1, 0.1, 0.1); // Comienza muy peque√±o
    magicTree.visible = false;
    droneScene.add(magicTree);
    
    // Crear sistema de rayos
    createLightningSystem();
  }
  
  function createLightningSystem() {
    lightning = new THREE.Group();
    
    // Crear m√∫ltiples rayos M√ÅS REALISTAS Y DETALLADOS
    for(let i = 0; i < 12; i++) {
      // Rayo principal
      const lightningGeo = new THREE.CylinderGeometry(0.1, 0.3, 35);
      const lightningMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 1.2
      });
      const bolt = new THREE.Mesh(lightningGeo, lightningMat);
      
      // Posicionar rayos SOBRE EL √ÅRBOL (fuera del huerto)
      bolt.position.set(
        30 + (Math.random() - 0.5) * 25, // Centrado en la nueva posici√≥n del √°rbol
        40,
        30 + (Math.random() - 0.5) * 25
      );
      bolt.rotation.x = (Math.random() - 0.5) * 0.4;
      bolt.rotation.z = (Math.random() - 0.5) * 0.4;
      
      bolt.userData = {
        originalIntensity: 1.2,
        flickerSpeed: 2 + Math.random() * 3
      };
      
      lightning.add(bolt);
      
      // Rayos secundarios (ramificaciones)
      if (i < 6) {
        for(let j = 0; j < 3; j++) {
          const branchGeo = new THREE.CylinderGeometry(0.05, 0.15, 15);
          const branchMat = new THREE.MeshBasicMaterial({ 
            color: 0xaaaaff,
            emissive: 0xaaaaff,
            emissiveIntensity: 0.8
          });
          const branch = new THREE.Mesh(branchGeo, branchMat);
          branch.position.set(
            bolt.position.x + (Math.random() - 0.5) * 8,
            bolt.position.y - 10 - (j * 5),
            bolt.position.z + (Math.random() - 0.5) * 8
          );
          branch.rotation.x = (Math.random() - 0.5) * 0.6;
          branch.rotation.z = (Math.random() - 0.5) * 0.6;
          lightning.add(branch);
        }
      }
    }
    
    // Efecto de destello en el suelo donde cae el rayo
    const flashGeo = new THREE.CircleGeometry(8);
    const flashMat = new THREE.MeshBasicMaterial({ 
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 2,
      transparent: true,
      opacity: 0
    });
    const flash = new THREE.Mesh(flashGeo, flashMat);
    flash.rotation.x = -Math.PI / 2;
    flash.position.set(30, 0.1, 30); // En la base del √°rbol
    flash.userData = { isFlash: true };
    lightning.add(flash);
    
    lightning.visible = false;
    droneScene.add(lightning);
  }

  function animateEpicSequence(sequenceTime) {
    if (!spaceship) return;
    
    // ESCENA 1: Nave espacial con fuego saliendo del suelo (0-3 segundos)
    if (sequenceTime <= 3000) {
      const progress = sequenceTime / 3000;
      
      // Asegurar que la nave est√© en la posici√≥n correcta y visible
      if (spaceship) {
        spaceship.position.set(-100, -20 + (progress * 25), -100); // Elevar gradualmente desde abajo
        spaceship.visible = true;
      }
      
      // Mostrar fuego gradualmente
      if (fireParticles) {
        fireParticles.visible = true;
        
        // Animar part√≠culas de fuego CON M√ÅS REALISMO
        fireParticles.children.forEach((flame, index) => {
          if (flame.userData.isSmoke) {
            // Animaci√≥n del humo: sube y se dispersa
            flame.position.y = flame.userData.initialY + Math.sin(sequenceTime * 0.002 + index) * 3;
            flame.scale.setScalar(1 + Math.sin(sequenceTime * 0.003 + index) * 0.4);
            flame.material.opacity = 0.3 + Math.sin(sequenceTime * 0.004 + index) * 0.2;
          } else {
            // Animaci√≥n del fuego: parpadeo y movimiento err√°tico
            flame.position.y = flame.userData.initialY + Math.sin(sequenceTime * 0.01 + index) * 3;
            flame.position.x = flame.userData.initialX + Math.sin(sequenceTime * 0.015 + index) * 1.5;
            flame.position.z = flame.userData.initialZ + Math.cos(sequenceTime * 0.012 + index) * 1.5;
            
            flame.scale.set(
              1 + Math.sin(sequenceTime * 0.008 + index) * 0.4,
              1 + Math.sin(sequenceTime * 0.012 + index) * 0.6,
              1 + Math.sin(sequenceTime * 0.008 + index) * 0.4
            );
            
            // Cambiar color de llama M√ÅS DIN√ÅMICO
            const time = sequenceTime * 0.01;
            const hue = 0.15 - (Math.sin(time + index * flame.userData.bobSpeed) * 0.12);
            const brightness = 0.5 + Math.sin(time * 2 + index) * 0.3;
            flame.material.color.setHSL(hue, 1, brightness);
            flame.material.opacity = 0.7 + Math.sin(time * 3 + index) * 0.3;
          }
        });
      }
      
      // La nave se ilumina gradualmente
      if (spaceship) {
        spaceship.children.forEach(part => {
          if (part.material) {
            part.material.emissive = new THREE.Color(0x444444).multiplyScalar(progress);
          }
        });
      }
      
      // Vista lateral dram√°tica
      droneCamera.position.set(30, 15, 0);
      droneCamera.lookAt(0, 10, 0);
    }
    // ESCENA 2: Nave despegando (3-6 segundos)
    else if (sequenceTime <= 6000) {
      const progress = (sequenceTime - 3000) / 3000;
      
      // Nave se eleva
      if (spaceship) {
        spaceship.position.y = progress * 40;
        spaceship.rotation.y = progress * Math.PI * 2; // Gira mientras sube
        
        // M√°ximo brillo
        spaceship.children.forEach(part => {
          if (part.material) {
            part.material.emissive = new THREE.Color(0x666666);
          }
        });
      }
      
      // Fuego m√°s intenso
      if (fireParticles) {
        fireParticles.children.forEach((flame, index) => {
          flame.position.y = flame.userData.initialY + Math.sin(sequenceTime * 0.02 + index) * 4;
          flame.scale.set(2, 3, 2);
        });
      }
      
      // C√°mara sigue la nave
      droneCamera.position.set(25, 20 + progress * 20, 25);
      droneCamera.lookAt(0, spaceship.position.y, 0);
    }
    // ESCENA 3: T√∫nel de colores infinito (6-10 segundos)
    else if (sequenceTime <= 10000) {
      const progress = (sequenceTime - 6000) / 4000;
      
      // Ocultar nave y fuego COMPLETAMENTE
      if (spaceship) {
        spaceship.visible = false;
        spaceship.position.set(-1000, -1000, -1000); // Mover muy lejos
      }
      if (fireParticles) {
        fireParticles.visible = false;
        fireParticles.position.set(-1000, -1000, -1000); // Mover muy lejos
      }
      
      // Mostrar t√∫nel de colores
      if (colorTunnel) {
        colorTunnel.visible = true;
        
        // Animar t√∫nel movi√©ndose hacia adelante
        colorTunnel.children.forEach((ring, index) => {
          ring.position.z = ring.userData.originalZ + (sequenceTime - 6000) * 0.05;
          ring.rotation.z += 0.02;
          ring.rotation.x += 0.01;
          
          // Si el anillo pasa muy adelante, lo movemos atr√°s
          if (ring.position.z > 50) {
            ring.position.z = ring.userData.originalZ - 600;
          }
        });
      }
      
      // Cambiar color de fondo din√°micamente
      const hue = (sequenceTime * 0.001) % 1;
      droneScene.background = new THREE.Color().setHSL(hue, 0.8, 0.3);
      
      // C√°mara viajando por el t√∫nel
      droneCamera.position.set(0, 0, 0);
      droneCamera.lookAt(0, 0, -100);
    }
    // ESCENA 4: √Årbol creciendo r√°pidamente (10-13 segundos)
    else if (sequenceTime <= 13000) {
      const progress = (sequenceTime - 10000) / 3000;
      
      // Ocultar t√∫nel
      if (colorTunnel) colorTunnel.visible = false;
      
      // Restaurar fondo normal
      droneScene.background = new THREE.Color(0x87CEEB);
      
      // Mostrar √°rbol creciendo
      if (magicTree) {
        magicTree.visible = true;
        const scale = 0.1 + (progress * 0.9); // Crece de 0.1 a 1.0
        magicTree.scale.set(scale, scale, scale);
        
        // Rotaci√≥n suave mientras crece
        magicTree.rotation.y = progress * Math.PI * 2;
      }
      
      // Vista del √°rbol creciendo (MIRAR HACIA LA NUEVA POSICI√ìN)
      droneCamera.position.set(45, 15, 45);
      droneCamera.lookAt(30, 10, 30); // Mirar hacia el √°rbol en su nueva posici√≥n
    }
    // ESCENA 5: Rayo golpea el √°rbol y se incendia (13-18 segundos) - EXTENDIDA
    else if (sequenceTime <= 18000) {
      const progress = (sequenceTime - 13000) / 5000; // Ahora son 5 segundos
      
      // Mostrar rayos a los 0.2 segundos con M√ÅS INTENSIDAD
      if (progress > 0.04 && lightning) {
        lightning.visible = true;
        
        // Animar rayos CON M√ÅS REALISMO
        lightning.children.forEach((bolt, index) => {
          if (bolt.userData.isFlash) {
            // Destello en el suelo
            const flashIntensity = Math.sin(sequenceTime * 0.02) * 0.5 + 0.5;
            bolt.material.opacity = progress < 0.2 ? flashIntensity * 0.8 : 0;
          } else {
            // Rayos parpadeando
            const flicker = Math.sin(sequenceTime * bolt.userData.flickerSpeed) * 0.3 + 0.7;
            bolt.scale.y = 1 + Math.sin(sequenceTime * 0.03 + index) * 0.4;
            bolt.material.emissiveIntensity = bolt.userData.originalIntensity * flicker;
            
            // Hacer que algunos rayos aparezcan y desaparezcan
            bolt.visible = Math.sin(sequenceTime * 0.01 + index) > -0.3;
          }
        });
      }
      
      // √Årbol se incendia despu√©s del rayo CON LLAMAS REALES
      if (progress > 0.2 && magicTree) {
        magicTree.children.forEach((part, partIndex) => {
          if (part.material) {
            // Cambiar a colores de fuego GRADUALMENTE
            const fireIntensity = Math.min((progress - 0.2) / 0.4, 1);
            
            if (part.material.color.g > 0.3) { // Partes verdes (hojas)
              // Transici√≥n de verde a naranja a rojo
              const red = 1;
              const green = Math.max(0.8 - fireIntensity, 0);
              const blue = Math.max(0.2 - fireIntensity, 0);
              part.material.color.setRGB(red, green, blue);
              part.material.emissive = new THREE.Color(0.6, 0.2, 0).multiplyScalar(fireIntensity);
              part.material.emissiveIntensity = fireIntensity * 2;
            } else if (part.material.color.r > 0.3 && part.material.color.r < 0.8) { // Tronco/ramas
              // Tronco se pone negro carbonizado con brasas
              const char = Math.min(fireIntensity * 1.5, 1);
              part.material.color.setRGB(0.1 + char * 0.3, 0.05 + char * 0.15, 0.05);
              part.material.emissive = new THREE.Color(0.4, 0.1, 0).multiplyScalar(fireIntensity);
            }
          }
        });
        
        // CREAR PART√çCULAS DE FUEGO ALREDEDOR DEL √ÅRBOL
        if (progress > 0.3 && !magicTree.userData.fireCreated) {
          magicTree.userData.fireCreated = true;
          
          // Crear llamas flotantes alrededor del √°rbol
          for(let i = 0; i < 40; i++) {
            const flameGeo = new THREE.SphereGeometry(0.3 + Math.random() * 0.4);
            const flameMat = new THREE.MeshBasicMaterial({ 
              color: new THREE.Color().setHSL(0.1 - Math.random() * 0.1, 1, 0.6),
              transparent: true,
              opacity: 0.8,
              emissive: new THREE.Color(0.8, 0.2, 0),
              emissiveIntensity: 1.5
            });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            
            const angle = (i / 40) * Math.PI * 2;
            const radius = 5 + Math.random() * 8;
            flame.position.set(
              30 + Math.cos(angle) * radius, // Posici√≥n del √°rbol + radio
              3 + Math.random() * 12,
              30 + Math.sin(angle) * radius
            );
            
            flame.userData = {
              originalY: flame.position.y,
              speed: 1 + Math.random() * 2,
              bobSpeed: 1 + Math.random() * 2,
              startTime: sequenceTime
            };
            
            droneScene.add(flame);
            
            // Guardar referencia para limpiar despu√©s
            if (!magicTree.userData.fireParticles) {
              magicTree.userData.fireParticles = [];
            }
            magicTree.userData.fireParticles.push(flame);
          }
        }
        
        // Animar part√≠culas de fuego del √°rbol
        if (magicTree.userData.fireParticles) {
          magicTree.userData.fireParticles.forEach((flame, index) => {
            const elapsed = sequenceTime - flame.userData.startTime;
            flame.position.y = flame.userData.originalY + Math.sin(elapsed * 0.005 + index) * 2;
            flame.scale.setScalar(1 + Math.sin(elapsed * 0.01 + index) * 0.3);
            
            // Cambiar color con el tiempo
            const hue = 0.1 - (Math.sin(elapsed * 0.003 + index) * 0.1);
            flame.material.color.setHSL(hue, 1, 0.6);
          });
        }
      }
      
      // Vista dram√°tica del √°rbol en llamas M√ÅS CINEMATOGR√ÅFICA
      const angle = progress * Math.PI * 3; // 1.5 rotaciones completas
      const height = 15 + Math.sin(progress * Math.PI * 4) * 5;
      const distance = 25 + Math.sin(progress * Math.PI * 2) * 5;
      
      droneCamera.position.set(
        30 + Math.sin(angle) * distance, // Centrado en el √°rbol
        height,
        30 + Math.cos(angle) * distance
      );
      droneCamera.lookAt(30, 12, 30); // Mirar al √°rbol ardiendo
      
      // Mostrar calavera al final
      if (progress >= 0.85 && !skullShown) {
        setTimeout(() => {
          showSkullAndBlackWhiteEffect();
        }, 200);
      }
    }
  }

  let skullShown = false; // Prevenir m√∫ltiples ejecuciones
  
  function showSkullAndBlackWhiteEffect() {
    if (skullShown) return; // Evitar que se ejecute m√∫ltiples veces
    skullShown = true;
    
    console.log("Iniciando efecto de calavera"); // Debug
    
    // Crear overlay de calavera
    const skullOverlay = document.createElement('div');
    skullOverlay.id = 'skullOverlay';
    skullOverlay.style.position = 'fixed';
    skullOverlay.style.top = '50%';
    skullOverlay.style.left = '50%';
    skullOverlay.style.transform = 'translate(-50%, -50%)';
    skullOverlay.style.fontSize = '120px';
    skullOverlay.style.zIndex = '2500';
    skullOverlay.style.animation = 'skullAppear 1s ease-out, skullPulse 2s ease-in-out infinite 1s';
    skullOverlay.style.textShadow = '0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(128, 0, 128, 0.8)';
    skullOverlay.textContent = 'üíÄ';
    
    // CSS para la animaci√≥n de calavera con palpitaci√≥n fantasmal MEJORADA
    if (!document.getElementById('skullAnimationStyles')) {
      const skullStyle = document.createElement('style');
      skullStyle.id = 'skullAnimationStyles';
      skullStyle.textContent = `
        @keyframes skullAppear {
          0% { 
            transform: translate(-50%, -50%) scale(0) rotate(360deg); 
            opacity: 0; 
            filter: hue-rotate(180deg);
          }
          50% {
            transform: translate(-50%, -50%) scale(1.3) rotate(180deg); 
            opacity: 0.8;
            filter: hue-rotate(90deg);
          }
          100% { 
            transform: translate(-50%, -50%) scale(1) rotate(0deg); 
            opacity: 1; 
            filter: hue-rotate(0deg);
          }
        }
        
        @keyframes skullPulse {
          0%, 100% { 
            transform: translate(-50%, -50%) scale(1); 
            opacity: 1; 
            text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(128, 0, 128, 0.8);
          }
          25% {
            transform: translate(-50%, -50%) scale(1.1); 
            opacity: 0.9; 
            text-shadow: 0 0 40px rgba(255, 100, 100, 1), 0 0 80px rgba(255, 0, 0, 0.8);
          }
          50% { 
            transform: translate(-50%, -50%) scale(1.3); 
            opacity: 0.6; 
            text-shadow: 0 0 50px rgba(255, 255, 255, 1), 0 0 100px rgba(128, 0, 128, 1), 0 0 120px rgba(255, 0, 0, 0.6);
          }
          75% {
            transform: translate(-50%, -50%) scale(1.15); 
            opacity: 0.8; 
            text-shadow: 0 0 35px rgba(100, 255, 100, 1), 0 0 70px rgba(0, 128, 0, 0.8);
          }
        }
      `;
      document.head.appendChild(skullStyle);
    }
    
    document.body.appendChild(skullOverlay);
    
    // Efecto blanco y negro en toda la vista
    const blackWhiteFilter = document.createElement('div');
    blackWhiteFilter.id = 'blackWhiteFilter';
    blackWhiteFilter.style.position = 'fixed';
    blackWhiteFilter.style.top = '0';
    blackWhiteFilter.style.left = '0';
    blackWhiteFilter.style.width = '100vw';
    blackWhiteFilter.style.height = '100vh';
    blackWhiteFilter.style.background = 'rgba(0, 0, 0, 0.4)';
    blackWhiteFilter.style.backdropFilter = 'grayscale(100%) contrast(200%) brightness(80%)';
    blackWhiteFilter.style.zIndex = '2400';
    blackWhiteFilter.style.animation = 'blackWhiteAppear 2s ease-in-out';
    
    if (!document.getElementById('filterAnimationStyles')) {
      const filterStyle = document.createElement('style');
      filterStyle.id = 'filterAnimationStyles';
      filterStyle.textContent = `
        @keyframes blackWhiteAppear {
          0% { 
            opacity: 0; 
            backdrop-filter: grayscale(0%) contrast(100%) brightness(100%); 
          }
          50% {
            opacity: 0.7; 
            backdrop-filter: grayscale(50%) contrast(150%) brightness(90%); 
          }
          100% { 
            opacity: 1; 
            backdrop-filter: grayscale(100%) contrast(200%) brightness(80%); 
          }
        }
      `;
      document.head.appendChild(filterStyle);
    }
    
    document.body.appendChild(blackWhiteFilter);
    
    // Cambiar el fondo de la escena 3D a blanco y negro
    if (droneScene) {
      droneScene.background = new THREE.Color(0x606060); // Gris m√°s oscuro para efecto B&N
    }
    
    // Despu√©s de 5 segundos, terminar el intro
    setTimeout(() => {
      endIntro();
      // Limpiar elementos de forma segura
      const skullElement = document.getElementById('skullOverlay');
      const filterElement = document.getElementById('blackWhiteFilter');
      if (skullElement) document.body.removeChild(skullElement);
      if (filterElement) document.body.removeChild(filterElement);
    }, 5000);
  }

  function endIntro() {
    state.introCompleted = true;
    if (droneAnimationId) {
      cancelAnimationFrame(droneAnimationId);
    }
    
    // Limpiar TODOS los elementos de la nave para evitar bugs
    if (spaceship) {
      droneScene.remove(spaceship);
      spaceship = null;
    }
    if (fireParticles) {
      droneScene.remove(fireParticles);
      fireParticles = null;
    }
    if (colorTunnel) {
      droneScene.remove(colorTunnel);
      colorTunnel = null;
    }
    if (magicTree) {
      // Limpiar part√≠culas de fuego del √°rbol
      if (magicTree.userData.fireParticles) {
        magicTree.userData.fireParticles.forEach(flame => {
          droneScene.remove(flame);
        });
        magicTree.userData.fireParticles = [];
      }
      droneScene.remove(magicTree);
      magicTree = null;
    }
    if (lightning) {
      droneScene.remove(lightning);
      lightning = null;
    }
    
    if (droneRenderer && droneRenderer.domElement) {
      droneView.removeChild(droneRenderer.domElement);
    }
    
    // Limpiar la escena completamente
    if (droneScene) {
      while (droneScene.children.length > 0) {
        droneScene.remove(droneScene.children[0]);
      }
    }
    
    preIntro.style.display = 'none';
    startScreen.style.display = 'flex';
  }

  // ----- SISTEMA DE TIEMPO Y CLIMA -----
  function updateTimeAndWeather(deltaTime) {
    // Actualizar tiempo del d√≠a
    timeSystem.currentTime += (deltaTime * 24000) / timeSystem.dayDuration; // 24 horas en dayDuration ms
    if (timeSystem.currentTime >= 24) {
      timeSystem.currentTime -= 24;
    }

    // Cambiar clima cada cierto tiempo
    const now = Date.now();
    if (now - timeSystem.lastWeatherChange > 45000) { // Cambio de clima cada 45 segundos
      const weatherOptions = ['sunny', 'rainy', 'cloudy'];
      const randomWeather = weatherOptions[Math.floor(Math.random() * weatherOptions.length)];
      timeSystem.weather = randomWeather;
      timeSystem.lastWeatherChange = now;
      timeSystem.isRaining = randomWeather === 'rainy';
      
      if (timeSystem.isRaining) {
        showToast('üåßÔ∏è ¬°Ha comenzado a llover! Las plantas crecer√°n m√°s r√°pido ‚ú®');
        createRainEffect();
      } else {
        removeRainEffect();
        if (randomWeather === 'sunny') {
          showToast('‚òÄÔ∏è ¬°El sol ha salido! Perfecto para el jard√≠n ‚ú®');
        } else {
          showToast('‚òÅÔ∏è D√≠a nublado, ideal para plantas delicadas ‚ú®');
        }
      }
    }

    updateTimeDisplay();
    updateSkyColor();
  }

  function updateTimeDisplay() {
    const hour = Math.floor(timeSystem.currentTime);
    const minute = Math.floor((timeSystem.currentTime - hour) * 60);
    const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    
    let timeIcon, timePeriod;
    if (hour >= 6 && hour < 12) {
      timeIcon = 'üåÖ';
      timePeriod = 'Ma√±ana';
    } else if (hour >= 12 && hour < 18) {
      timeIcon = '‚òÄÔ∏è';
      timePeriod = 'D√≠a';
    } else if (hour >= 18 && hour < 21) {
      timeIcon = 'üåÜ';
      timePeriod = 'Tarde';
    } else {
      timeIcon = 'üåô';
      timePeriod = 'Noche';
    }

    let weatherIcon, weatherText;
    switch(timeSystem.weather) {
      case 'rainy':
        weatherIcon = 'üåßÔ∏è';
        weatherText = 'Lluvioso';
        break;
      case 'cloudy':
        weatherIcon = '‚òÅÔ∏è';
        weatherText = 'Nublado';
        break;
      default:
        weatherIcon = '‚òÄÔ∏è';
        weatherText = 'Soleado';
    }

    document.getElementById('timeDisplay').textContent = `${timeIcon} ${timePeriod} - ${timeString}`;
    document.getElementById('weatherDisplay').textContent = `${weatherIcon} ${weatherText}`;
  }

  function updateSkyColor() {
    if (!scene) return;
    
    const hour = timeSystem.currentTime;
    let skyColor;
    
    if (hour >= 6 && hour < 8) {
      // Amanecer - naranjas y rosas
      const t = (hour - 6) / 2;
      skyColor = new THREE.Color().lerpColors(
        new THREE.Color(0x1a1a2e), // Azul noche
        new THREE.Color(0xff7f50)  // Naranja amanecer
      , t);
    } else if (hour >= 8 && hour < 18) {
      // D√≠a - azul cielo
      skyColor = new THREE.Color(0x87CEEB);
    } else if (hour >= 18 && hour < 20) {
      // Atardecer - naranjas y rojos
      const t = (hour - 18) / 2;
      skyColor = new THREE.Color().lerpColors(
        new THREE.Color(0x87CEEB), // Azul d√≠a
        new THREE.Color(0xff4500)  // Rojo atardecer
      , t);
    } else {
      // Noche - azul oscuro con estrellas
      skyColor = new THREE.Color(0x1a1a2e);
    }

    // Modificar color si est√° lloviendo
    if (timeSystem.isRaining) {
      skyColor = skyColor.clone().multiplyScalar(0.6); // M√°s oscuro cuando llueve
    }

    scene.background = skyColor;
    
    // Actualizar iluminaci√≥n
    if (directionalLight) {
      if (hour >= 7 && hour < 19) {
        // D√≠a - luz solar
        directionalLight.color.setHex(0xffffff);
        directionalLight.intensity = timeSystem.isRaining ? 0.4 : 0.8;
      } else {
        // Noche - luz de luna
        directionalLight.color.setHex(0x404080);
        directionalLight.intensity = 0.2;
      }
    }

    // Crear estrellas en la noche
    if (hour < 6 || hour >= 21) {
      createStars();
    } else {
      removeStars();
    }
  }

  let starsGroup;
  function createStars() {
    if (starsGroup) return; // Ya existen estrellas
    
    starsGroup = new THREE.Group();
    const starGeometry = new THREE.SphereGeometry(0.1, 4, 4);
    const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5 });
    
    for (let i = 0; i < 200; i++) {
      const star = new THREE.Mesh(starGeometry, starMaterial);
      const radius = 100 + Math.random() * 200;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      
      star.position.x = radius * Math.sin(phi) * Math.cos(theta);
      star.position.y = 50 + radius * Math.cos(phi);
      star.position.z = radius * Math.sin(phi) * Math.sin(theta);
      
      starsGroup.add(star);
    }
    
    scene.add(starsGroup);
  }

  function removeStars() {
    if (starsGroup) {
      scene.remove(starsGroup);
      starsGroup = null;
    }
  }

  // Sistema de lluvia
  let rainParticles = [];
  function createRainEffect() {
    const rainContainer = document.getElementById('rainEffect');
    rainContainer.innerHTML = ''; // Limpiar lluvia anterior
    
    for (let i = 0; i < 100; i++) {
      const drop = document.createElement('div');
      drop.style.position = 'absolute';
      drop.style.left = Math.random() * 100 + '%';
      drop.style.top = '-10px';
      drop.style.width = '2px';
      drop.style.height = '20px';
      drop.style.background = 'linear-gradient(transparent, rgba(173, 216, 230, 0.8), transparent)';
      drop.style.borderRadius = '0 0 50% 50%';
      drop.style.animation = `rainDrop ${0.5 + Math.random() * 0.5}s linear infinite`;
      drop.style.animationDelay = Math.random() * 2 + 's';
      
      rainContainer.appendChild(drop);
    }
    
    // Agregar CSS para la animaci√≥n de lluvia
    if (!document.getElementById('rainCSS')) {
      const style = document.createElement('style');
      style.id = 'rainCSS';
      style.textContent = `
        @keyframes rainDrop {
          from { transform: translateY(-10px); opacity: 1; }
          to { transform: translateY(100vh); opacity: 0.3; }
        }
      `;
      document.head.appendChild(style);
    }
  }

  function removeRainEffect() {
    const rainContainer = document.getElementById('rainEffect');
    rainContainer.innerHTML = '';
  }

  // ----- MANEJO DE CONFIGURACIONES -----
  function loadSettings() {
    const saved = localStorage.getItem('gardenDreamConfig');
    if (saved) {
      gameConfig = {...gameConfig, ...JSON.parse(saved)};
      applySettings();
    }
  }

  function applySettings() {
    document.getElementById('playerName').value = gameConfig.playerName;
    document.getElementById('farmNameInput').value = gameConfig.farmName;
    document.getElementById('sfxVolume').value = gameConfig.sfxVolume;
    document.getElementById('musicVolume').value = gameConfig.musicVolume;
    document.getElementById('startingMoney').value = gameConfig.startingMoney;
    document.getElementById('autoSave').checked = gameConfig.autoSave;
    document.getElementById('showTutorial').checked = gameConfig.showTutorial;
    document.getElementById('visualTheme').value = gameConfig.visualTheme;
    
    document.getElementById('sfxValue').textContent = gameConfig.sfxVolume;
    document.getElementById('musicValue').textContent = gameConfig.musicVolume;
    
    state.money = gameConfig.startingMoney;
    state.farmName = gameConfig.farmName;
  }

  function saveSettings() {
    gameConfig.playerName = document.getElementById('playerName').value;
    gameConfig.farmName = document.getElementById('farmNameInput').value;
    gameConfig.sfxVolume = document.getElementById('sfxVolume').value;
    gameConfig.musicVolume = document.getElementById('musicVolume').value;
    gameConfig.startingMoney = parseInt(document.getElementById('startingMoney').value);
    gameConfig.autoSave = document.getElementById('autoSave').checked;
    gameConfig.showTutorial = document.getElementById('showTutorial').checked;
    gameConfig.visualTheme = document.getElementById('visualTheme').value;
    
    localStorage.setItem('gardenDreamConfig', JSON.stringify(gameConfig));
    
    state.money = gameConfig.startingMoney;
    state.farmName = gameConfig.farmName;
    updateUI();
    
    showToast('¬°Configuraci√≥n guardada exitosamente! ‚ú®üåü');
  }

  // ----- INICIAR JUEGO -----
  function startGame() {
    startScreen.style.display = 'none';
    gameScreen.classList.add('active');
    state.gameStarted = true;
    
    initializeGame();
    
    if (gameConfig.showTutorial) {
      setTimeout(() => {
        showToast('¬°Bienvenido al Reino M√°gico! üåü Usa el joystick azul para moverte y toca elementos para interactuar ‚ú®');
      }, 1000);
    }
  }

  // ----- EVENT LISTENERS -----
  document.getElementById('skipIntro').addEventListener('click', endIntro);
  document.getElementById('btnPlay').addEventListener('click', startGame);
  document.getElementById('btnSettings').addEventListener('click', () => {
    settingsPanel.style.display = 'block';
  });
  document.getElementById('btnOnline').addEventListener('click', () => {
    onlinePanel.style.display = 'block';
  });
  document.getElementById('btnCredits').addEventListener('click', () => {
    showToast('üåü Garden Dreams v2.0 - Redise√±ado con estilo Roblox üíé‚ú®');
  });
  document.getElementById('closeSettings').addEventListener('click', () => {
    settingsPanel.style.display = 'none';
  });
  document.getElementById('closeOnline').addEventListener('click', () => {
    onlinePanel.style.display = 'none';
  });
  document.getElementById('backFromOnline').addEventListener('click', () => {
    onlinePanel.style.display = 'none';
  });
  document.getElementById('saveSettings').addEventListener('click', saveSettings);

  // Sliders
  document.getElementById('sfxVolume').addEventListener('input', (e) => {
    document.getElementById('sfxValue').textContent = e.target.value;
  });
  document.getElementById('musicVolume').addEventListener('input', (e) => {
    document.getElementById('musicValue').textContent = e.target.value;
  });

  // Opciones online
  document.getElementById('createRoom').addEventListener('click', () => {
    showToast('üèóÔ∏è ¬°Creando jard√≠n m√°gico! Funci√≥n pr√≥ximamente... ‚ú®');
  });
  document.getElementById('joinRoomBtn').addEventListener('click', () => {
    const code = document.getElementById('roomCode').value;
    if (code.length === 6) {
      showToast(`üö™ Intentando entrar al jard√≠n: ${code}... üåü`);
    } else {
      showToast('‚ùå Ingresa un c√≥digo m√°gico de 6 caracteres ‚ú®');
    }
  });
  document.getElementById('quickMatch').addEventListener('click', () => {
    showToast('‚ö° Buscando jard√≠n m√°gico disponible... üåà');
  });
  document.getElementById('leaderboard').addEventListener('click', () => {
    showToast('üèÜ Tabla de jardineros legendarios pr√≥ximamente... üëë');
  });

  document.getElementById('btnMenu').addEventListener('click', () => {
    if (confirm('¬øRegresar al reino m√°gico principal? (Tu progreso se guardar√° autom√°ticamente) üåü')) {
      if (gameConfig.autoSave) {
        localStorage.setItem('gardenDreamSave', JSON.stringify(state));
      }
      startScreen.style.display = 'flex';
      gameScreen.classList.remove('active');
      state.gameStarted = false;
    }
  });

  // ----- THREE.JS Y JUEGO -----
  let scene, camera, renderer;
  let plots = [], cropsGroup, plotGroup, storeGroup, npcGroup;
  let yaw = 0, pitch = 0;
  let joy = {x: 0, y: 0, active: false};
  let vel = new THREE.Vector3();
  let canJump = true;
  let directionalLight, hemisphereLight;

  function initializeGame() {
    if (state.gameStarted && scene) return;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    
    camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 600);
    camera.position.set(0, 1.7, 15);
    
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    const existingCanvas = document.querySelector('#gameScreen canvas');
    if (existingCanvas) existingCanvas.remove();
    
    gameScreen.appendChild(renderer.domElement);

    // Iluminaci√≥n m√°gica
    hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x4CAF50, 0.9);
    scene.add(hemisphereLight);
    
    directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
    directionalLight.position.set(10, 15, 5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Suelo m√°gico
    const ground = new THREE.Mesh(
      new THREE.BoxGeometry(80, 0.4, 80), 
      new THREE.MeshStandardMaterial({color: 0x4CAF50})
    );
    ground.position.y = -0.2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Paredes para delimitar el √°rea
    const wallHeight = 8;
    const wallThickness = 1;
    const areaSize = 80;
    
    // Pared norte
    const northWall = new THREE.Mesh(
      new THREE.BoxGeometry(areaSize + wallThickness, wallHeight, wallThickness),
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    northWall.position.set(0, wallHeight/2, -areaSize/2);
    northWall.castShadow = true;
    scene.add(northWall);
    
    // Pared sur
    const southWall = new THREE.Mesh(
      new THREE.BoxGeometry(areaSize + wallThickness, wallHeight, wallThickness),
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    southWall.position.set(0, wallHeight/2, areaSize/2);
    southWall.castShadow = true;
    scene.add(southWall);
    
    // Pared oeste
    const westWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, areaSize),
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    westWall.position.set(-areaSize/2, wallHeight/2, 0);
    westWall.castShadow = true;
    scene.add(westWall);
    
    // Pared este
    const eastWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, areaSize),
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    eastWall.position.set(areaSize/2, wallHeight/2, 0);
    eastWall.castShadow = true;
    scene.add(eastWall);

    // Plots con marco azul estilo Roblox
    plots = [];
    plotGroup = new THREE.Group();
    scene.add(plotGroup);
    
    const plotSize = 2.2;
    const gap = 0.8;
    for(let rz = 0; rz < 3; rz++) {
      for(let cx = 0; cx < 4; cx++) {
        const x = -6 + cx * (plotSize + gap);
        const z = -2 + rz * (plotSize + gap);
        plots.push({x, z});
        
        const soil = new THREE.Mesh(
          new THREE.BoxGeometry(plotSize, 0.14, plotSize), 
          new THREE.MeshStandardMaterial({color: 0x8B4513}) // Marr√≥n tierra
        );
        soil.position.set(x, 0.02, z);
        soil.receiveShadow = true;
        soil.userData = {type: 'plot', plotIndex: plots.length - 1};
        plotGroup.add(soil);
        
        // Marco azul estilo Roblox
        const frameMat = new THREE.MeshStandardMaterial({color: 0x1877f2});
        const thickness = 0.16;
        
        const borders = [
          {pos: [x, 0.2, z - plotSize/2 - thickness/2], size: [plotSize + thickness, 0.3, thickness]},
          {pos: [x, 0.2, z + plotSize/2 + thickness/2], size: [plotSize + thickness, 0.3, thickness]},
          {pos: [x - plotSize/2 - thickness/2, 0.2, z], size: [thickness, 0.3, plotSize + thickness]},
          {pos: [x + plotSize/2 + thickness/2, 0.2, z], size: [thickness, 0.3, plotSize + thickness]}
        ];
        
        borders.forEach(border => {
          const frame = new THREE.Mesh(new THREE.BoxGeometry(...border.size), frameMat);
          frame.position.set(...border.pos);
          frame.castShadow = true;
          plotGroup.add(frame);
        });
      }
    }

    // Tienda m√°gica con colores azules
    storeGroup = new THREE.Group();
    
    const storeBase = new THREE.Mesh(
      new THREE.BoxGeometry(12, 4, 8), 
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    storeBase.position.set(0, 2, -15);
    storeBase.castShadow = true;
    storeBase.userData = {type: 'store'};
    storeGroup.add(storeBase);

    const roof = new THREE.Mesh(
      new THREE.BoxGeometry(13, 0.3, 9), 
      new THREE.MeshStandardMaterial({color: 0x0d47a1})
    );
    roof.position.set(0, 4.2, -15);
    storeGroup.add(roof);

    const sign = new THREE.Mesh(
      new THREE.BoxGeometry(8, 1, 0.2), 
      new THREE.MeshStandardMaterial({color: 0x42a5f5})
    );
    sign.position.set(0, 3.5, -10.9);
    storeGroup.add(sign);

    const door = new THREE.Mesh(
      new THREE.BoxGeometry(2, 3, 0.1), 
      new THREE.MeshStandardMaterial({
        color: 0x64b5f6, 
        transparent: true, 
        opacity: 0.7
      })
    );
    door.position.set(0, 1.5, -10.95);
    door.userData = {type: 'store'};
    storeGroup.add(door);

    // NPC Mago con colores azules
    npcGroup = new THREE.Group();
    
    const npcBody = new THREE.Mesh(
      new THREE.BoxGeometry(0.6, 1.2, 0.4), 
      new THREE.MeshStandardMaterial({color: 0x1877f2})
    );
    npcBody.position.y = 1.2;
    npcGroup.add(npcBody);
    
    const npcHead = new THREE.Mesh(
      new THREE.BoxGeometry(0.4, 0.4, 0.4), 
      new THREE.MeshStandardMaterial({color: 0xffdbcb})
    );
    npcHead.position.y = 2.0;
    npcGroup.add(npcHead);
    
    // Sombrero m√°gico azul
    const hat = new THREE.Mesh(
      new THREE.ConeGeometry(0.3, 0.5), 
      new THREE.MeshStandardMaterial({color: 0x0d47a1})
    );
    hat.position.y = 2.5;
    npcGroup.add(hat);
    
    npcGroup.position.set(1.5, 0, -14);
    npcGroup.userData = {type: 'npc'};
    storeGroup.add(npcGroup);
    
    scene.add(storeGroup);

    cropsGroup = new THREE.Group();
    scene.add(cropsGroup);

    setupControls();
    updateUI();
    updateInventory();
    updateCartDisplay();
    rebuildPlants();
    buildSeedStore();
    gameLoop();
  }

  function setupControls() {
    camera.rotation.order = 'YXZ';
    
    function applyCam() {
      camera.rotation.set(pitch, yaw, 0, 'YXZ');
    }

    // Joystick
    const joyEl = document.getElementById('joystick');
    const knob = document.getElementById('knob');
    
    joyEl.addEventListener('touchstart', (e) => {
      joy.active = true;
      e.preventDefault();
    }, {passive: false});
    
    joyEl.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joyEl.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let dx = touch.clientX - centerX;
      let dy = touch.clientY - centerY;
      
      const maxRadius = rect.width * 0.42;
      const distance = Math.hypot(dx, dy);
      const clamp = distance > maxRadius ? maxRadius / distance : 1;
      
      dx *= clamp;
      dy *= clamp;
      
      knob.style.transform = `translate(${dx}px, ${dy}px)`;
      
      joy.x = dx / maxRadius;
      joy.y = dy / maxRadius;
    }, {passive: false});
    
    joyEl.addEventListener('touchend', () => {
      joy.active = false;
      joy.x = 0;
      joy.y = 0;
      knob.style.transform = 'translate(-50%, -50%)';
    });

    // Look pad
    const lookPad = document.getElementById('lookPad');
    let lastLook = null;
    let lookVelX = 0, lookVelY = 0;
    
    lookPad.addEventListener('touchstart', e => {
      lastLook = e.touches[0];
    }, {passive: true});
    
    lookPad.addEventListener('touchmove', e => {
      const touch = e.touches[0];
      if (!lastLook) {
        lastLook = touch;
        return;
      }
      
      const dx = touch.clientX - lastLook.clientX;
      const dy = touch.clientY - lastLook.clientY;
      lastLook = touch;
      
      const sensitivity = 0.001;
      lookVelX += (-dx * sensitivity);
      lookVelY += (-dy * sensitivity);
    }, {passive: true});
    
    lookPad.addEventListener('touchend', () => {
      lastLook = null;
    });

    // Raycast para toque
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('touchend', (e) => {
      if (e.touches.length === 0 && e.changedTouches.length === 1) {
        const touch = e.changedTouches[0];
        
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        if (intersects.length > 0) {
          handleTouch(intersects[0], touch);
        }
      }
    });

    // Game loop
    let lastTime = performance.now();
    
    window.gameLoop = function() {
      if (!state.gameStarted) return;
      
      requestAnimationFrame(gameLoop);
      
      const currentTime = performance.now();
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.05);
      lastTime = currentTime;
      
      // Actualizar sistema de tiempo y clima
      updateTimeAndWeather(deltaTime);
      
      lookVelX *= 0.9;
      lookVelY *= 0.9;
      
      yaw += lookVelX;
      pitch += lookVelY;
      
      const maxPitch = Math.PI / 2 - 0.1;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
      
      applyCam();
      
      // Movimiento
      if (joy.active) {
        const speed = 8;
        
        const forward = new THREE.Vector3(
          Math.sin(yaw), 
          0, 
          Math.cos(yaw)
        ).normalize();
        
        const right = new THREE.Vector3().crossVectors(
          new THREE.Vector3(0, 1, 0), 
          forward
        ).normalize();
        
        const moveForward = -joy.y;
        const moveRight = joy.x;
        
        vel.x += (forward.x * moveForward + right.x * moveRight) * speed * deltaTime;
        vel.z += (forward.z * moveForward + right.z * moveRight) * speed * deltaTime;
      }
      
      vel.x *= 0.9;
      vel.z *= 0.9;
      vel.y -= 25 * deltaTime;
      
      camera.position.x += vel.x * deltaTime;
      camera.position.y += vel.y * deltaTime;
      camera.position.z += vel.z * deltaTime;
      
      if (camera.position.y < 1.7) {
        camera.position.y = 1.7;
        vel.y = 0;
        canJump = true;
      }
      
      // Animar plantas con efecto m√°gico
      if (cropsGroup) {
        cropsGroup.children.forEach((plant, index) => {
          plant.rotation.y += 0.01;
          plant.position.y = 0.2 + Math.sin(currentTime * 0.001 + index) * 0.05;
        });
      }
      
      // Animar NPC mago
      if (state.npcState === 'idle' && npcGroup) {
        npcGroup.rotation.y = Math.sin(currentTime * 0.001) * 0.2;
        npcGroup.position.y = Math.sin(currentTime * 0.002) * 0.1;
      }
      
      renderer.render(scene, camera);
    };
  }

  // Funciones del juego
  function handleTouch(intersect, touch) {
    const object = intersect.object;
    const userData = object.userData;
    
    showTouchIndicator(touch.clientX, touch.clientY);
    
    if (userData.type === 'store' || userData.type === 'npc') {
      const distance = camera.position.distanceTo(intersect.point);
      if (distance < 8) {
        openStore();
      } else {
        showToast('Ac√©rcate m√°s a la tienda m√°gica üè™‚ú®');
      }
    } else if (userData.type === 'plot') {
      handlePlotTouch(userData.plotIndex);
    } else if (userData.type === 'plant') {
      handlePlantTouch(userData.plotIndex);
    }
  }

  function showTouchIndicator(x, y) {
    const indicator = document.createElement('div');
    indicator.className = 'touchIndicator';
    indicator.style.left = (x - 20) + 'px';
    indicator.style.top = (y - 20) + 'px';
    document.body.appendChild(indicator);
    
    setTimeout(() => {
      document.body.removeChild(indicator);
    }, 800);
  }

  function handlePlotTouch(plotIndex) {
    const existing = state.plants.find(p => p.plotIndex === plotIndex);
    if (existing) {
      showToast('¬°Ya hay una planta m√°gica creciendo aqu√≠! üå±‚ú®');
      return;
    }
    
    const availableSeed = Object.keys(state.inventory).find(seedId => state.inventory[seedId] > 0);
    
    if (!availableSeed) {
      showToast('¬°Necesitas semillas m√°gicas! üå±üí´ Visita la tienda');
      return;
    }
    
    state.inventory[availableSeed]--;
    state.plants.push({
      plotIndex: plotIndex,
      plantedAt: Date.now(),
      type: availableSeed
    });
    
    rebuildPlants();
    updateInventory();
    updateUI();
    showToast(`¬°${seedCatalog.find(s => s.id === availableSeed).name} plantada con magia! üå±‚ú®`);
  }

  function handlePlantTouch(plotIndex) {
    const plantIndex = state.plants.findIndex(p => p.plotIndex === plotIndex);
    if (plantIndex === -1) return;
    
    const plantData = state.plants[plantIndex];
    const age = Date.now() - plantData.plantedAt;
    const seedInfo = seedCatalog.find(s => s.id === plantData.type);
    let growTime = seedInfo ? seedInfo.growTime : 12000;
    
    // Acelerar crecimiento si est√° lloviendo
    if (timeSystem.isRaining) {
      growTime *= 0.5; // 50% m√°s r√°pido con lluvia
    }
    
    if (age >= growTime) {
      state.plants.splice(plantIndex, 1);
      const reward = 5 + Math.floor(Math.random() * 5);
      state.money += reward;
      
      if (Math.random() < 0.4) {
        state.inventory[plantData.type] = (state.inventory[plantData.type] || 0) + 1;
      }
      
      rebuildPlants();
      updateInventory();
      updateUI();
      showToast(`¬°${seedInfo.name} cosechada! +${reward} monedas m√°gicas ‚ú®üí∞`);
    } else {
      const remainingTime = Math.ceil((growTime - age) / 1000);
      showToast(`La planta estar√° lista en ${remainingTime}s üå±‚è∞`);
    }
  }

  function updateInventory() {
    const grid = document.getElementById('inventoryGrid');
    grid.innerHTML = '';
    
    seedCatalog.forEach(seed => {
      const count = state.inventory[seed.id] || 0;
      const slot = document.createElement('div');
      slot.className = `inventorySlot ${count > 0 ? 'has-item' : ''}`;
      slot.innerHTML = count > 0 ? 
        `<div>${seed.icon}</div><div class="slotCount">${count}</div>` : 
        `<div style="opacity:0.3">${seed.icon}</div>`;
      grid.appendChild(slot);
    });
  }

  function rebuildPlants() {
    if (!cropsGroup) return;
    
    while (cropsGroup.children.length) {
      cropsGroup.remove(cropsGroup.children[0]);
    }
    
    const now = Date.now();
    
    state.plants.forEach(plant => {
      const plot = plots[plant.plotIndex];
      if (!plot) return;
      
      const seedInfo = seedCatalog.find(s => s.id === plant.type);
      let growTime = seedInfo ? seedInfo.growTime : 12000;
      
      // Acelerar crecimiento si est√° lloviendo
      if (timeSystem.isRaining) {
        growTime *= 0.5;
      }
      
      const age = now - plant.plantedAt;
      const growthStage = Math.min(age / growTime, 1);
      
      const size = 0.3 + growthStage * 0.9;
      const color = growthStage >= 1 ? 0xffd700 : seedInfo.color;
      
      const plantMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.4 * size, 0.8 * size, 0.4 * size),
        new THREE.MeshStandardMaterial({
          color, 
          emissive: growthStage >= 1 ? 0x444400 : 0x000000
        })
      );
      
      plantMesh.position.set(plot.x, 0.2 + (0.4 * size), plot.z);
      plantMesh.castShadow = true;
      plantMesh.userData = {type: 'plant', plotIndex: plant.plotIndex, plantedAt: plant.plantedAt};
      
      cropsGroup.add(plantMesh);
    });
  }

  function buildSeedStore() {
    const seedGrid = document.getElementById('seedGrid');
    seedGrid.innerHTML = '';
    
    seedCatalog.forEach(seed => {
      const seedDiv = document.createElement('div');
      seedDiv.className = 'seedDisplay';
      seedDiv.innerHTML = `
        <div class="seedIcon">${seed.icon}</div>
        <div class="seedName">${seed.name}</div>
        <div class="seedPrice">üí∞ ${seed.price} monedas</div>
        <div class="seedDesc">${seed.desc}</div>
        <button class="btn" onclick="addToCart('${seed.id}')">Agregar al carrito ‚ú®</button>
      `;
      seedGrid.appendChild(seedDiv);
    });
  }

  window.addToCart = function(seedId) {
    const seed = seedCatalog.find(s => s.id === seedId);
    if (!seed) return;
    
    const existing = state.cart.find(item => item.id === seedId);
    if (existing) {
      existing.quantity++;
    } else {
      state.cart.push({...seed, quantity: 1});
    }
    
    updateCartDisplay();
    showToast(`${seed.name} agregada al carrito m√°gico! üõí‚ú®`);
  }

  function updateCartDisplay() {
    document.getElementById('cartCount').textContent = state.cart.reduce((sum, item) => sum + item.quantity, 0);
    document.getElementById('cartTotalAmount').textContent = state.cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    const cartItems = document.getElementById('cartItems');
    cartItems.innerHTML = '';
    
    state.cart.forEach((item, index) => {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'cartItem';
      itemDiv.innerHTML = `
        <span>${item.icon} ${item.name}</span>
        <span>x${item.quantity}</span>
        <span>${item.price * item.quantity} monedas</span>
        <button class="btn" onclick="removeFromCart(${index})" style="padding:8px;">‚ùå</button>
      `;
      cartItems.appendChild(itemDiv);
    });
  }

  window.removeFromCart = function(index) {
    state.cart.splice(index, 1);
    updateCartDisplay();
  }

  function openStore() {
    document.getElementById('storePanel').style.display = 'block';
    showToast('¬°Bienvenido a la Tienda de Semillas M√°gicas! üè™‚ú®');
  }

  function updateUI() {
    document.getElementById('money').textContent = state.money;
    document.getElementById('farmName').textContent = state.farmName;
  }

  function showToast(message, duration = 3500) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.style.display = 'block';
    
    setTimeout(() => {
      toast.style.display = 'none';
    }, duration);
  }

  // Event listeners adicionales
  document.getElementById('btnInteract').addEventListener('click', () => {
    const playerPos = camera.position;
    const storeDistance = playerPos.distanceTo(new THREE.Vector3(0, 1.7, -12));
    
    if (storeDistance < 6) {
      openStore();
    } else {
      showToast('Ac√©rcate a algo m√°gico para interactuar ‚ú®');
    }
  });

  document.getElementById('btnJump').addEventListener('click', () => {
    if (canJump) {
      vel.y = 10;
      canJump = false;
      showToast('¬°Salto m√°gico! ‚ú®ü¶ã');
    }
  });

  document.getElementById('closeStore').addEventListener('click', () => {
    document.getElementById('storePanel').style.display = 'none';
  });

  document.getElementById('viewCart').addEventListener('click', () => {
    document.getElementById('cartPanel').style.display = 'block';
  });

  document.getElementById('closeCart').addEventListener('click', () => {
    document.getElementById('cartPanel').style.display = 'none';
  });

  document.getElementById('checkout').addEventListener('click', () => {
    const total = state.cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
    
    if (state.cart.length === 0) {
      showToast('¬°El carrito est√° vac√≠o! üõí');
      return;
    }
    
    if (state.money < total) {
      showToast('¬°No tienes suficientes monedas m√°gicas! üí∞‚ú®');
      return;
    }
    
    state.money -= total;
    
    state.cart.forEach(item => {
      state.inventory[item.id] = (state.inventory[item.id] || 0) + item.quantity;
    });
    
    state.cart = [];
    
    updateUI();
    updateInventory();
    updateCartDisplay();
    document.getElementById('storePanel').style.display = 'none';
    document.getElementById('cartPanel').style.display = 'none';
    
    showToast(`¬°Compra realizada con √©xito! ‚ú®üí´ Total: ${total} monedas`);
  });

  document.getElementById('proceedCheckout').addEventListener('click', () => {
    document.getElementById('checkout').click();
  });

  // Resize handler
  window.addEventListener('resize', () => {
    if (camera && renderer) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    if (droneCamera && droneRenderer) {
      droneCamera.aspect = window.innerWidth / window.innerHeight;
      droneCamera.updateProjectionMatrix();
      droneRenderer.setSize(window.innerWidth, window.innerHeight);
    }
  });

  // ----- INICIALIZACI√ìN -----
  loadSettings();
  applySettings();
  
  // Iniciar intro de drone autom√°ticamente
  createDroneIntro();

  // Auto-crecimiento de plantas cada segundo
  setInterval(() => {
    if (state.gameStarted && state.plants.length > 0) {
      rebuildPlants(); // Actualizar visualmente las plantas
    }
  }, 1000);

  </script>
</body>
</html>
